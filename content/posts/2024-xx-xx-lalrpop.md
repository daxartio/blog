---
draft: true
date: 2024-09-23
slug: lalrpop
comments: true
authors:
  - daxartio
categories:
  - rust
tags:
  - rust
  - lalr
---

# LALRPOP LR(1) parser generator for Rust

Если у вас есть желание написать свой ЯП (язык программирования), то вы скорее всего начнёте с синтаксиса языка.
Скорее всего синтаксис будет предполагать ваш опыт работы и это будет выбор между функциональным стилем или императивным, или то и другое.

В любом случае, когда будете придумывать язык, обратите внимание на [LALRPOP](https://github.com/lalrpop/lalrpop).

LALRPOP — это удобный способ описать грамматику языка и иметь готовый парсер без глубоких знаний как устроены сами парсеры.

> Грамматика в контексте компьютерных наук — это набор правил, описывающих, как формировать допустимые конструкции или выражения в языке

Насчёт понимания, хотелось бы всё равно знать семантику, описанной грамматики, в контексте LALRPOP, это позволит не допустить ошибок и использовать фичи сразу.

В посте попробую быстро описать основные возможности, но в любом случае есть [первоисточник](https://lalrpop.github.io/lalrpop/), где есть примеры и подробное описание.

<!-- more -->

## Что такое LALR?

> LALR (Look-Ahead LR) — это тип парсера, используемого для синтаксического анализа контекстно-свободных грамматик. Он относится к семейству LR-парсеров, которые анализируют текст или код снизу вверх, пытаясь определить правильные грамматические конструкции.

> Основная идея LALR-парсера заключается в том, что он пытается предсказать, что будет дальше, заглядывая на один символ вперед (это называется lookahead). Этот механизм помогает парсеру решать, какое действие предпринять: сдвигать символы в стек или сворачивать последовательность символов по определённому правилу грамматики.

До того, как я написал свою "идеальную грамматику" и "язык мечты", я просто решил взять готовый инструмент на Rust-е с примерами и повторять нужные конструкции. В качестве примера взял грамматику калькулятора. Когда начало что-то простое получаться, я подумал: "Ничёсе, это так изи", но в некоторых кейсах возникали ошибки парсинга и мне приходилось терять много времени просто экспереминтируя с синтаксисом. В большинстве случаев я просто забивал и делал убогий стиль, например, всё разделял ";", даже блоки конструкций типа struct или function. Код выглядел вот так:

```rust
struct MyStruct {field1, field2};

fn do_smth() {
    MyStruct{field1: ..., field2: ...} |> println;
};

fn main() {
    do_smth();
};
```

Наша грамматика состоит из терминалов и нетерминалов и в этом коде мне было просто описать терминал ";" и, что все инструкции (Statement) разделены этим терминалом ";".

> Терминалы — это основные, конечные символы, из которых строится программа или выражение. Это могут быть ключевые слова, операторы, идентификаторы, числа, скобки и т.д.
> Нетерминалы — это категории или абстрактные элементы, которые описывают структуры языка и могут быть разложены на другие нетерминалы или терминалы. Нетерминалы определяют правила и структуры, по которым можно построить грамматически корректные выражения.

Грамматика была примерно такой:

```rust
pub Program = Semilicon<Stmt>;

Semicolon<T>: Vec<T> = {
    <mut v:(<T> ";")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
```

Я сразу захожу с козырей и попробую объяснить сложные конструкции. Наша программа состоит из каких-то инструкций и все эти инструкции разделены ";". Причем последняя инструкция может не иметь ";". Обратите внимание, у нас здесь написано `<e:T?>`.
В `<...>` указываем название нашему нетерминалу `e`, справа отмечам его тип, сейчас это дженерик тип `T`, и что этого `T` может не быть, так как он отмечен "?". В самой правой части `match` мы просто проверяем переменную `e`. Если её нет, то просто возвращаем список нетерминалов `T`, которые разделены ";", или добавляем последний нетерминал в список и возвращаем всё.

Данная конструкция `<mut v:(<T> ";")*>` говорит, что у нас есть какая-то изменяемая переменная `mut v`, и эта переменная имеет тип `(<T> ";")*` — то есть список нетерминалов `T`, разделенные ";". Обратите внимнаие на `*` в конце, это как раз и даёт LALRPOP знать, что мы здесь хотим иметь массив элементов. И в данном случае этот массив может быть пустым. Забегая вперед, если указать `+`, то в массиве должен быть хотя бы один эламент. Это полезно в кейсах, когда есть конфликт грамматики. Например, `(1, 2, 3, 4)` и пустых скобок`()`, в первом случае мы имеем какой-то кортеж, а справа у нас `unit` тип. Если явно не определить кортеж как `"(" <v:(<T> ",")+> ")"`, то парсинг просто сломается, потому что также подходит терминал `()`.

Так как мы объявили generic тип `Semilicon`, мы можем просто определить нашу программу как массив Stmt, разделенные ";".
Каждый Stmt содержит другие выражения нашей грамматики, про это чуть ниже.

```rust
pub Program = Semilicon<Stmt>;
```
