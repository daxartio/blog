---
draft: true
date: 2023-12-02
comments: true
authors:
  - daxartio
categories:
  - rust
tags:
  - rust
  - rc
---

# Создаем свой Rc (Reference Counting) на Rust

В этой статье я хочу рассказать, как создать свой Rc на Rust. Для этого мы будем использовать только стандартную библиотеку.
Зачем это нужно? Это хорошая практика, чтобы лучше понять, как работает Rc. Разумеется, статья расчитана на тех, кто начинает изучать Rust.

<!-- more -->

## Что такое Rc?

У данных есть владелец. Владелец — это переменная, которая хранит в себе данные.
Когда владелец удаляется, данные удаляются из памяти.
Удаление происходит автоматически, когда владелец выходит из области видимости.
По умолчанию, владелец может быть только один и компилятор нам это гарантирует.

Представим ситуацию, когда есть несколько владельцев.
Как тогда компилятор будет понимать, когда удалять данные?
Для этого мы можем использовать умный указатель Rc.

Rc — это счетчик ссылок. Он позволяет считать, сколько раз мы используем один и тот же объект.
Когда счетчик ссылок становится равным нулю, объект удаляется из памяти.

## Немного теории

Для начала, давайте разберем базовые понятия, которые нам понадобятся для создания своего Rc.

### Trait Clone

`Clone` — это trait, который позволяет создавать копию объекта (не путать с трейтом `Copy`, который копирует по битно на стеке).
Мы можешь переопределить метод clone, чтобы создавать якобы копию объекта.
Таким образом, компилятор не будет ругаться, что мы пытаемся иметь несколько владельцев.

```rust
let a = S::new();
let b = a.clone();
```

### Trait Drop

`Drop` — это trait, метод которого вызывается, когда переменная выходит из области видимости.
Мы также можем переопределить метод drop, чтобы выполнять какие-то действия.

```rust
let a = S::new();
{
    let b = S::new();
} // b выходит из области видимости и вызывается метод drop
```

### Trait Deref/DerefMut

`Deref` — это trait, который позволяет нам определить поведение для оператора разыменования.

```rust
println!("{:?}", *a);
```

### Итог

Возможно вы догоадались, что переопределив методы `clone` и `drop` мы можем создать свой Rc.

Алгоритм будет следующий:
1. `let a = MyRc::new(val)` — создаем объект и счетчик ссылок равный 1. Важно отметить, что мы создаем наш счетчик и данные в куче, чтобы он не удалился при выходе из области видимости.
2. `a.clone()` — увеличиваем счетчик ссылок и копируем указатель на данные. Счетчик ссылок хранится в структуре Rc.
3. `Drop` — уменьшаем счетчик ссылок и удаляем данные, если счетчик ссылок равен нулю.

## Реализация

Давайте реализуем наш Rc. Для начала, создадим структуру, которая будет хранить данные и счетчик ссылок.

```rust
struct MyRcBox<T: ?Sized> {
    count: Cell<usize>,
    val: T,
}
```

`?Sized` — означает, что мы можем использовать любой тип данных, который неизвестен на этапе компиляции.
`Cell` — типаж, который позволяет нам изменять данные внутри структуры, даже если она неизменяемая.
Работает только с типами, которые реализуют типаж `Copy`.

## Ссылки

- [Github gist](https://gist.github.com/daxartio/6537d0c13e0d1cdb48734bec31cac3f2)
