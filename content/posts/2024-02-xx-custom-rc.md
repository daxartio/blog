---
draft: true
date: 2024-01-29
comments: true
authors:
  - daxartio
categories:
  - rust
tags:
  - rust
  - rc
---

# Создаем свой Rc (Reference Counting) на Rust

В этой статье я хочу рассказать, как создать свой Rc на Rust. Для этого мы будем использовать только стандартную библиотеку.
Зачем это нужно? Это хорошая практика, чтобы лучше понять, как работает Rc. Разумеется, статья расчитана на тех, кто начинает изучать Rust.

<!-- more -->

## Что такое Rc?

У данных есть владелец (owner). Владелец — это переменная, которая хранит в себе данные.
Когда владелец удаляется, данные удаляются из памяти.
Удаление происходит автоматически, когда владелец выходит из области видимости.
По умолчанию, владелец может быть только один и компилятор нам это гарантирует.

Представим ситуацию, когда есть несколько владельцев.
Как тогда компилятор будет понимать, когда удалять данные?
Для этого мы можем использовать умный указатель Rc.
По сути, мы переносим управление памятью в runtime.

Rc — это счетчик ссылок. Он позволяет считать, сколько раз мы используем один и тот же объект.
Когда счетчик ссылок становится равным нулю, объект удаляется из памяти. Примерно так работает стандартный Rc.

## Немного теории

Для начала, давайте разберем базовые понятия, которые нам понадобятся для создания своего Rc.

### Trait Clone

`Clone` — это trait, который позволяет создавать копию объекта (не путать с трейтом `Copy`, который копирует по битно на стеке).
Мы можешь переопределить метод clone, чтобы создавать якобы копию объекта.
Таким образом, компилятор не будет ругаться, что мы пытаемся иметь несколько владельцев.

```rust
let a = S::new();
let b = a.clone();
```

### Trait Drop

`Drop` — это trait, метод которого вызывается, когда переменная выходит из области видимости.
Мы также можем переопределить метод drop, чтобы выполнять какие-то действия, когда переменная выходит из блока.

```rust
let a = S::new();
{
    let b = S::new();
} // b выходит из области видимости и вызывается метод drop
```

### Trait Deref/DerefMut

`Deref` — это trait, который позволяет нам определить поведение для оператора разыменования.

```rust
println!("{:?}", *a);
```

Только синтаскический сахар, чтобы было проще использовать объекты.

`DerefMut` — аналогично, только для изменяемых ссылок.

### Итог

Возможно вы догоадались, что переопределив методы `clone` и `drop` мы можем создать свой Rc.

Алгоритм будет следующий:
1. `let a = MyRc::new(val)` — создаем объект и счетчик ссылок равный 1. Важно отметить, что мы создаем наш счетчик и данные в куче, чтобы он не удалился при выходе из области видимости.
2. `a.clone()` — увеличиваем счетчик ссылок и копируем указатель на данные. Счетчик ссылок хранится в структуре Rc.
3. `Drop` — уменьшаем счетчик ссылок и удаляем данные, если счетчик ссылок равен нулю.

## Реализация

Давайте реализуем наш Rc. Для начала, создадим структуру, которая будет хранить данные и счетчик ссылок.

```rust
struct MyRcBox<T: ?Sized> {
    count: Cell<usize>,
    val: T,
}
```

`?Sized` — означает, что мы можем использовать любой тип данных, который неизвестен на этапе компиляции.
`Cell` — типаж, который позволяет нам изменять данные внутри структуры, даже если она неизменяемая.
Работает только с типами, которые реализуют типаж `Copy`.

Теперь, создадим структуру, которая будет хранить указатель на данные и счетчик ссылок.

```rust
struct MyRc<T: ?Sized> {
    ptr: NonNull<MyRcBox<T>>,
}
```

`NonNull` — это указатель, который гарантирует, что он не равен None.

Теперь, давайте реализуем методы для нашего Rc.

```rust
impl<T> MyRc<T> {
    fn new(val: T) -> Self {
        Self {
            ptr: Box::leak(Box::new(MyRcBox {
                count: Cell::new(1),
                val,
            }))
            .into(),
        }
    }
}
```

`Box::leak` — это метод, который позволяет нам получить указатель на данные, которые хранятся в куче.
Также данный метод гарантирует, что данные не будут удалены из памяти при выходе из области видимости.
Это может привести к утечкам памяти, think about it.

## Ссылки

- [Github gist](https://gist.github.com/daxartio/6537d0c13e0d1cdb48734bec31cac3f2)
